# P3 单周期CPU 设计文档

***

## 一、模块规格

* ### IFU（取指令单元）

| 端口 | 方向 | 功能 |
| --- | --- | --- |
| clk | I | 时钟 |
| rst | I | 异步复位 |
| imm26[25:0] | I | `jal`：26位立即数 |
| imm16[15:0] | I | `beq`：16位偏移量 |
| RA[31:0] | I | `jr`：保存的32位目标地址 |
| NPCOp[1:0] | I | NPC计算模式的控制码 |
| Zero | I | `beq`：rs与rt相等的比较结果 |
| LessZero | I | rs与rt相减是否小于0 |
| Instr[31:0] | O | 当前指令内容 |

其中IFU包含以下PC、NPC、IM三个子电路。

* PC（程序计数器）

    > | 端口 | 方向 | 功能 |
    > | --- | --- | --- |
    > | clk | I | 时钟 |
    > | rst | I | 异步复位 |
    > | DI[31:0] | I | 下一条指令地址 |
    > | DO[31:0] | O | 当前指令地址 |
    > * reset后初始地址为**0x0000_3000**，~~实现方式参考~~[~~网上教程~~](https://www.cnblogs.com/BUAA-Wander/p/11790154.html)。
* NPC（增加对`jal`和`jr`支持）
    > | 端口 | 方向 | 功能 |
    > | --- | --- | --- |
    > | PC[31:0] | I | 当前指令的地址 |
    > | imm26/16[25:0] | I | `jal`：26位偏移量；<br/>`beq`：16位偏移量 |
    > | A[31:0] | I | `jr`：保存的32位目标地址 |
    > | NPCOp[1:0] | I | NPC计算模式的控制码 |
    > | Zero | I | `beq`：rs与rt是否相等的比较结果 |
    > | LessZero | I | rs与rt相减是否小于0 |
    > | NPC[31:0] | O | 下一条指令的地址 |
    > | PC+4[31:0] | O | `jal`：PC+4 |
    > * | NPCOp | 00 | 01 | 10 | 11 |
    >   | --- | --- | --- | --- | --- |
    >   | 功能 | normal | `beq` | `jr` | `jal` |
* IM（指令存储器）
    > | 端口 | 方向 | 功能 |
    > | --- | --- | --- |
    > | PC[31:0] | I | 当前指令地址 |
    > | Instr[31:0] | O | 当前指令内容 |
    > * 用 ROM 实现，容量为 4096 × 32bit，实际地址宽度仅为 12 位。
    > * 由于地址均为4倍数，因此需要将[1:0]两位舍去，取[13:2]位。
    > * 由于ROM不支持从**0x0000_3000**开始，所以PC进去之后要减去**0x0000_3000**。

* ### GRF（通用寄存器组，也称为寄存器文件、寄存器堆）

| 端口 | 方向 | 功能 |
| --- | --- | --- |
| clk | I | 时钟 |
| rst | I | 异步复位 |
| A1[4:0] | I | 读取的第一个寄存器编号 |
| A2[4:0] | I | 读取的第二个寄存器编号 |
| A3[4:0] | I | 写入的寄存器编号 |
| WD[31:0] | I | 写入值 |
| WE | I | 写使能，判断是否能够写入 |
| RD1[31:0] | O | 读取的第一个寄存器值 |
| RD2[31:0] | O | 读取的第二个寄存器值 |

* ### ALU（算术逻辑单元）

| 端口 | 方向 | 功能 |
| --- | --- | --- |
| A[31:0] | I | 第一个读入数rs |
| B[31:0] | I | 第二个读入数rt或imm |
| ALUOp[3:0] | I | ALU功能控制码 |
| C[31:0] | O | 运算结果输出 |
| Zero | O | 判断两个输入数是否相等 |
| LessZero | O | 判断A是否小于B |

| ALUOp | 0000 | 0001 | 0010 | 0011 |
| --- | --- | --- | --- | --- |
| 功能 | 加 | 减 | 或 | `lui`：将B加载到高16位，低16位置0 |

* ### DM（数据存储器）

| 端口 | 方向 | 功能 |
| --- | --- | --- |
| clk | I | 时钟（仅对写操作有效） |
| rst | I | 异步复位 |
| A[31:0] | I | 地址输入 |
| WD[31:0] | I | 需要写入到A地址的数据 |
| WE | I | 写操作使能，1时写0时读 |
| RD[31:0] | O | 读出的A地址的数据 |

* ### EXT（扩展单元）

| 端口 | 方向 | 功能 |
| --- | --- | --- |
| Input[15:0] | I | 待扩展数据 |
| EXTOp | I | 扩展功能控制码 |
| Output[31:0] | O | 32位扩展结果 |

| EXTOp | 0 | 1 |
| --- | --- | --- |
| 功能 | 无符号扩展 | 有符号扩展 |

* ### Controller（控制器）
  
  * 和逻辑
    | 端口 | 方向 | 功能 |
    | --- | --- | --- |
    | 略 | 略 | 略 |
    
  * 或逻辑
    | 端口 | 方向 | 功能 |
    | --- | --- | --- |
    | nop | I |  |
    | add | I |  |
    | sub | I |  |
    | ori | I |  |
    | lw | I |  |
    | sw | I |  |
    | lui | I |  |
    | beq | I |  |
    | NPCOp[1:0] | O | NPC功能控制码 |
    | RegWE | O | GRF写操作控制码 |
    | ALUOp[3:0] | O | ALU功能控制码 |
    | DmWE | O | DM写操作控制码 |
    | EXTOp | O | EXT功能控制码 |
    | RegA3Sel[1:0] | O | GRF的A3输入的选择器：00rd，01rt，10`$ra`/`$31` |
    | ALUBSel | O | ALU的B输入的选择器：0RD2，1imm |
    | RegWDSel[1:0] | O | GRF的WD输入的选择器：00ALUC，01DmOutput，10PC+4 |
  
    > * RegA3Sel：选择将哪个寄存器赋值——<br>00rd（指令中有3个寄存器），<br>01rt（指令中只有2个寄存器），<br>10常量31（`jal`将31号寄存器赋值）
    > * ALUBSel：选择是否有立即数参与运算——<br>1EXTimm（指令中含有imm并与一个寄存器的值参与ALU运算），<br>0RegRD2（指令中的两个寄存器的值需要ALU运算）
    > * RegWDSel：选择为寄存器赋值的内容来源——<br>00ALUC（Reg将ALU计算结果赋值到一个寄存器），<br>01DmRD（Reg将主存的值赋值给一个寄存器），<br>10PC+4（`jal`将PC+4赋给寄存器）
  
    | 指令 | `add` | `sub` | `ori` | `lw` | `sw` | `lui` | `beq` | `jr` | `jal` |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | NPCOp[1:0] | 00 | 00 | 00 | 00 | 00 | 00 | 01 | 10 | 11 |
    | RegWE | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 1 |
    | ALUOp[3:0] | 0000 | 0001 | 0010 | 0000 | 0000 | 0011 | 0001 | x | x |
    | DmWE | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
    | EXTOp | x | x | 0 | 1 | 1 | 0 | x | x | x |
    | RegA3Sel[1:0] | 00 | 00 | 01 | 01 | x | 01 | 00 | 00 | 10 |
    | ALUBSel | 0 | 0 | 1 | 1 | 1 | 1 | 0 | x | x |
    | RegWDSel[1:0] | 00 | 00 | 00 | 01 | x | 00 | x | 00 | 10 |

## 二、思考题

 *  上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

    > 状态存储：IM，DM，GRF，PC。
    >
    > 状态转移：NPC，ALU，EXT。

 *  现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

    > 合理。IM不需要写入功能，因此可以使用ROM；DM需要分开的写入和读取功能，因此可以使用RAM并且数据接口选择分离的引脚；GRF即寄存器，可以直接使用现有的register。

 *  在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

    > 没有。

 *  事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

    > `nop`不需要任何操作，只需进行正常的PC自增即可。

 *  阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

    > 测试的广度足够，但强度略有欠缺，如计算的数字不够大，`lw`与`sw`的偏移量从头到尾都是`$t0`等等。

## 三、测试方案

* 使用所给测试样例测试

  先将16进制机器码转换成2进制，再对照MIPS表翻译成MIPS语言，在Mars上运行，将结果进行比较。

* 自行在Mars中编写指令进行测试

  针对单个指令如`jr`，`jal`进行测试。
