# p4设计文档



***

![p3cpu](./p4设计文档.assets/cpu-1698720027391-2.png)

* p3logisim中的cpu架构，供参考。

## 一、模块规格

  ### 1.PC

  | 端口     | 方向 | 功能           |
  | -------- | ---- | ------------- |
  | clk      | I    | 时钟           |
  | rst      | I    | 同步复位       |
  | NPC[31:0] | I    | 下一条指令地址 |
  | PC[31:0] | O    | 当前指令地址   |

  ### 2.NPC

| 端口        | 方向 | 功能                                       |
| ----------- | ---- | ------------------------------------------ |
| PC[31:0]    | I    | 当前指令的地址                             |
| imm26[25:0] | I    | `jal`/`j`：26位偏移量                      |
| imm16[15:0] | I    | `beq`：16位偏移量                          |
| A[31:0]     | I    | `jr`/`jalr`：保存的32位目标地址            |
| NPCOp[2:0]  | I    | NPC计算模式的控制码                        |
| jump        | I    | `beq`：CMP中`$rs`与`$rt`是否相等的比较结果 |
| NPC[31:0]   | O    | 下一条指令的地址                           |
| PC_4[31:0]  | O    | 输出PC+4                                   |

  > | NPCOp | 000 | 001 | 010 | 011 |
  > | --- | --- | --- | --- | --- |
  > | 功能 | normal | `beq` | `jr`/`jalr` | `jal`/`j` |

  ### 3.IM

  | 端口        | 方向 | 功能         |
  | ----------- | ---- | ------------ |
  | PC[31:0]    | I    | 当前指令地址 |
  | Instr[31:0] | O    | 当前指令内容 |

  ### 4.GRF

| 端口      | 方向 | 功能                     |
| --------- | ---- | ------------------------ |
| clk       | I    | 时钟                     |
| rst       | I    | 同步复位                 |
| A1[4:0]   | I    | 读取的第一个寄存器编号   |
| A2[4:0]   | I    | 读取的第二个寄存器编号   |
| A3[4:0]   | I    | 写入的寄存器编号         |
| WD[31:0]  | I    | 写入值                   |
| WE        | I    | 写使能，判断是否能够写入 |
| PC[31:0]  | I    | 当前指令的地址           |
| RD1[31:0] | O    | 读取的第一个寄存器值     |
| RD2[31:0] | O    | 读取的第二个寄存器值     |

  ### 5.ALU

  | 端口       | 方向 | 功能                |
  | ---------- | ---- | ------------------- |
  | A[31:0]    | I    | 第一个读入数rs      |
  | B[31:0]    | I    | 第二个读入数rt或imm |
  | ALUOp[3:0] | I    | ALU功能控制码       |
  | C[31:0]    | O    | 运算结果输出        |

  > | ALUOp | 0000  | 0001  | 0010  | 0011  |
  > | ----- | ----- | ----- | ----- | ----- |
  > | 功能  | `add` | `sub` | `ori` | `lui` |

  ### 6.CMP

  | 端口       | 方向 | 功能          |
  | ---------- | ---- | ------------- |
  | rs[31:0]   | I    | `$rs`的值     |
  | rt[31:0]   | I    | `$rt`的值     |
  | CMPOp[2:0] | I    | CMP控制功能码 |
  | jump       | O    | 是否跳转      |

  > | CMPOp | 000   |
  > | ----- | ----- |
  > | 功能  | `beq` |

  ### 7.DM

| 端口      | 方向 | 功能                   |
| --------- | ---- | ---------------------- |
| clk       | I    | 时钟（仅对写操作有效） |
| rst       | I    | 同步复位               |
| A[31:0]   | I    | 地址输入               |
| WD[31:0]  | I    | 需要写入到A地址的数据  |
| WE        | I    | 写操作使能，1时写0时读 |
| DMOp[2:0] | I    | DM控制功能码           |
| PC[31:0]  | I    | 当前指令的地址         |
| RD[31:0]  | O    | 读出的A地址的数据      |

> | DMOp | 000        | 001        | 010        |
> | ---- | ---------- | ---------- | ---------- |
> | 功能 | `lw`、`sw` | `lb`、`sb` | `lh`、`sh` |

  ### 8.EXT

| 端口        | 方向 | 功能           |
| ----------- | ---- | -------------- |
| imm16[15:0] | I    | 16位待扩展数据 |
| EXTOp[1:0]  | I    | 扩展功能控制码 |
| imm32[31:0] | O    | 32位扩展结果   |

  > | EXTOp | 00         | 01         |
  > | ----- | ---------- | ---------- |
  > | 功能  | 无符号扩展 | 有符号扩展 |

  ### 9.splitter

  | 端口        | 方向 | 功能         |
  | ----------- | ---- | ------------ |
  | Instr[31:0] | I    | 指令         |
  | opcode[5:0] | O    | Instr[31:26] |
  | rs[4:0]     | O    | Instr[25:21] |
  | rt[4:0]     | O    | Instr[20:16] |
  | rd[4:0]     | O    | Instr[15:11] |
  | func[5:0]   | O    | Instr[5:0]   |
  | imm16[15:0] | O    | Instr[15:0]  |
  | imm26[25:0] | O    | Instr[25:0]  |

  ### 10. Controller

  * 和逻辑
    | 端口 | 方向 | 功能 |
    | --- | --- | --- |
    | 略 | 略 | 略 |
    
  * 或逻辑
    | 端口          | 方向 | 功能                                            |
    | ------------- | ---- | ----------------------------------------------- |
    | nop           | I    |                                                 |
    | add           | I    |                                                 |
    | sub           | I    |                                                 |
    | ori           | I    |                                                 |
    | lw            | I    |                                                 |
    | sw            | I    |                                                 |
    | lui           | I    |                                                 |
    | beq           | I    |                                                 |
    | NPCOp[2:0]    | O    | NPC功能控制码                                   |
    | RegWE         | O    | GRF写操作使能                                   |
    | ALUOp[3:0]    | O    | ALU功能控制码                                   |
    | CMPOp         | O    | CMP功能控制码                                   |
    | DmWE          | O    | DM写操作使能                                    |
    | DMOp[2:0]     | O    | DM控制功能码                                    |
    | EXTOp[1:0]    | O    | EXT功能控制码                                   |
    | RegA3Sel[1:0] | O    | GRF的A3输入的选择器：00rd，01rt，10`$ra`/`$31`  |
    | ALUBSel       | O    | ALU的B输入的选择器：0RD2，1imm                  |
    | RegWDSel[1:0] | O    | GRF的WD输入的选择器：00ALUC，01DmOutput，10PC+4 |
    
  > * RegA3Sel：选择将哪个寄存器赋值——<br>00rd（指令中有3个寄存器），<br>01rt（指令中只有2个寄存器），<br>10常量31（`jal`将31号寄存器赋值）
  > * ALUBSel：选择是否有立即数参与运算——<br>1EXTimm（指令中含有imm并与一个寄存器的值参与ALU运算），<br>0RegRD2（指令中的两个寄存器的值需要ALU运算）
  > * RegWDSel：选择为寄存器赋值的内容来源——<br>00ALUC（Reg将ALU计算结果赋值到一个寄存器），<br>01DmRD（Reg将主存的值赋值给一个寄存器），<br>10PC+4（`jal`将PC+4赋给寄存器）  

| 指令          | `add` | `sub` | `ori` | `lw` | `sw` | `lb` | `sb` | `lh` | `sh` | `lui` | `beq` | `jr` | `jal` | `j`  | `jalr` |
| ------------- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ---- | ----- | ---- | ------ |
| NPCOp[2:0]    | 000   | 000   | 000   | 000  | 000  | 000  | 000  | 000  | 000  | 000   | 001   | 010  | 011   | 011  | 010    |
| RegWE         | 1     | 1     | 1     | 1    | 0    | 1    | 0    | 1    | 0    | 1     | 0     | 0    | 1     | 0    | 1      |
| ALUOp[3:0]    | 0000  | 0001  | 0010  | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0011  | x     | x    | x     | x    | x      |
| CMPOp[2:0]    | x     | x     | x     | x    | x    | x    | x    | x    | x    | x     | 000   | x    | x     | x    | x      |
| DmWE          | 0     | 0     | 0     | 0    | 1    | 0    | 1    | 0    | 1    | 0     | 0     | 0    | 0     | 0    | 0      |
| DMOp[2:0]     | x     | x     | x     | 000  | 000  | 001  | 001  | 010  | 010  | x     | x     | x    | x     | x    | x      |
| EXTOp[1:0]    | x     | x     | 00    | 01   | 01   | 01   | 01   | 01   | 01   | 00    | x     | x    | x     | x    | x      |
| RegA3Sel[1:0] | 00    | 00    | 01    | 01   | x    | 01   | x    | 01   | x    | 01    | x     | x    | 10    | x    | 00     |
| ALUBSel       | 0     | 0     | 1     | 1    | 1    | 1    | 1    | 1    | 1    | 1     | 0     | x    | x     | x    | x      |
| RegWDSel[1:0] | 00    | 00    | 00    | 01   | x    | 01   | x    | 01   | x    | 00    | x     | 00   | 10    | x    | 10     |

## 二、思考题

1. 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？

   ![66.png](http://cscore.buaa.edu.cn/assets/cscore-image/refkxh/86953c72-c519-48b2-8cb8-7b2c90850e53/66.png)

   > addr来自ALU计算结果；由于每个字包含4字节，而addr是一个字节为一位，因此需要将addr除以4后当作地址。

2. 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。

   > 指令对应的控制信号如何取值：
   >
   > ```verilog
   > case (opcode)
   >     xxx:
   >         ctrl_signal_1 = 1;
   >     	ctrl_signal_2 = 1;
   >     yyy:
   >         ctrl_signal_1 = 2;
   >     	ctrl_signal_2 = 2;
   >     default:
   >         ctrl_signal_1 = 0;
   >     	ctrl_signal_2 = 0;
   > endcase
   > ```
   >
   > 控制信号每种取值所对应的指令：
   >
   > ```verilog
   > assign ctrl_signal_1 = 
   >     (opcode == xxx) ? 1 : 
   >     (opcode == yyy) ? 2 : 
   >     0;
   > assign ctrl_signal_2 =
   >     (opcode == xxx) ? 1 :
   >     (opcode == yyy) ? 2 :
   >     0;
   > ```
   >
   > 比较：
   >
   > 第一种较为直观，但工程量较大；第二种较为简便，但不直观。

3. 在相应的部件中，复位信号的设计都是**同步复位**，这与 P3 中的设计要求不同。请对比**同步复位**与**异步复位**这两种方式的 reset 信号与 clk 信号优先级的关系。

   > 同步复位时clk优先级高于reset；异步复位时reset优先级高于clk。

4. C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，`addi` 与 `addiu` 是等价的，`add` 与 `addu` 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。

   > `add`在溢出时会报告 `SignalException(IntegerOverflow)`，而`addu`会忽略溢出，并将溢出的最高位舍弃，因此忽略溢出时`add`与`addu`等价；`addi`与`addiu`同理。

## 三、测试方案

1. 将课下的16进制指令翻译成MIPS指令后，用Mars运行测试，并将结果比较

2. 自行在Mars中写MIPS指令进行专项测试，再导出到cpu中运行

   > ```assembly
   > ori $0, $0, 0
   > ori $t0, $0, 0x1234
   > lui $t1, 0x987
   > add $t2, $t0, $t1
   > sw $t2, 0
   > sub $t3, $t0, $t2
   > sw $t3, 4
   > lw $t4, 4
   > jal f
   > nop
   > jal over
   > nop
   > f:
   > lw $t5, 0
   > jr $ra
   > over:
   > ```

3. 用往届学长做的自动测试工具进行测试
4. 用同班大佬做的自动测试工具进行测试